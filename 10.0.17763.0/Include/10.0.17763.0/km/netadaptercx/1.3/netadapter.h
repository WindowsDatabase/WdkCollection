/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    NetAdapter.h

Abstract:

    This is the interfaces for the NetAdapter

Environment:

    kernel mode only

Revision History:

--*/

//
// NOTE: This header is generated by stubwork.  Please make any 
//       modifications to the corresponding template files 
//       (.x or .y) and use stubwork to regenerate the header
//

#ifndef _NETADAPTER_H_
#define _NETADAPTER_H_

#ifndef WDF_EXTERN_C
  #ifdef __cplusplus
    #define WDF_EXTERN_C       extern "C"
    #define WDF_EXTERN_C_START extern "C" {
    #define WDF_EXTERN_C_END   }
  #else
    #define WDF_EXTERN_C
    #define WDF_EXTERN_C_START
    #define WDF_EXTERN_C_END
  #endif
#endif

WDF_EXTERN_C_START


typedef enum _NET_PACKET_FILTER_TYPES_FLAGS {
    NET_PACKET_FILTER_TYPE_DIRECTED = NDIS_PACKET_TYPE_DIRECTED,
    NET_PACKET_FILTER_TYPE_MULTICAST = NDIS_PACKET_TYPE_MULTICAST,
    NET_PACKET_FILTER_TYPE_ALL_MULTICAST = NDIS_PACKET_TYPE_ALL_MULTICAST,
    NET_PACKET_FILTER_TYPE_BROADCAST = NDIS_PACKET_TYPE_BROADCAST,
    NET_PACKET_FILTER_TYPE_SOURCE_ROUTING = NDIS_PACKET_TYPE_SOURCE_ROUTING,
    NET_PACKET_FILTER_TYPE_PROMISCUOUS = NDIS_PACKET_TYPE_PROMISCUOUS,
    NET_PACKET_FILTER_TYPE_ALL_LOCAL = NDIS_PACKET_TYPE_ALL_LOCAL,
    NET_PACKET_FILTER_TYPE_MAC_FRAME = NDIS_PACKET_TYPE_MAC_FRAME,
    NET_PACKET_FILTER_TYPE_NO_LOCAL = NDIS_PACKET_TYPE_NO_LOCAL,
} NET_PACKET_FILTER_TYPES_FLAGS;

typedef enum _NET_ADAPTER_STATISTICS_FLAGS {
    NET_ADAPTER_STATISTICS_NO_FLAGS = 0,
    NET_ADAPTER_STATISTICS_XMIT_OK = NDIS_STATISTICS_XMIT_OK_SUPPORTED,
    NET_ADAPTER_STATISTICS_RCV_OK = NDIS_STATISTICS_RCV_OK_SUPPORTED,
    NET_ADAPTER_STATISTICS_XMIT_ERROR = NDIS_STATISTICS_XMIT_ERROR_SUPPORTED,
    NET_ADAPTER_STATISTICS_RCV_ERROR = NDIS_STATISTICS_RCV_ERROR_SUPPORTED,
    NET_ADAPTER_STATISTICS_RCV_NO_BUFFER = NDIS_STATISTICS_RCV_NO_BUFFER_SUPPORTED,
    NET_ADAPTER_STATISTICS_DIRECTED_BYTES_XMIT = NDIS_STATISTICS_DIRECTED_BYTES_XMIT_SUPPORTED,
    NET_ADAPTER_STATISTICS_DIRECTED_FRAMES_XMIT = NDIS_STATISTICS_DIRECTED_FRAMES_XMIT_SUPPORTED,
    NET_ADAPTER_STATISTICS_MULTICAST_BYTES_XMIT = NDIS_STATISTICS_MULTICAST_BYTES_XMIT_SUPPORTED,
    NET_ADAPTER_STATISTICS_MULTICAST_FRAMES_XMIT = NDIS_STATISTICS_MULTICAST_FRAMES_XMIT_SUPPORTED,
    NET_ADAPTER_STATISTICS_BROADCAST_BYTES_XMIT = NDIS_STATISTICS_BROADCAST_BYTES_XMIT_SUPPORTED,
    NET_ADAPTER_STATISTICS_BROADCAST_FRAMES_XMIT = NDIS_STATISTICS_BROADCAST_FRAMES_XMIT_SUPPORTED,
    NET_ADAPTER_STATISTICS_DIRECTED_BYTES_RCV = NDIS_STATISTICS_DIRECTED_BYTES_RCV_SUPPORTED,
    NET_ADAPTER_STATISTICS_DIRECTED_FRAMES_RCV = NDIS_STATISTICS_DIRECTED_FRAMES_RCV_SUPPORTED,
    NET_ADAPTER_STATISTICS_MULTICAST_BYTES_RCV = NDIS_STATISTICS_MULTICAST_BYTES_RCV_SUPPORTED,
    NET_ADAPTER_STATISTICS_MULTICAST_FRAMES_RCV = NDIS_STATISTICS_MULTICAST_FRAMES_RCV_SUPPORTED,
    NET_ADAPTER_STATISTICS_BROADCAST_BYTES_RCV = NDIS_STATISTICS_BROADCAST_BYTES_RCV_SUPPORTED,
    NET_ADAPTER_STATISTICS_BROADCAST_FRAMES_RCV = NDIS_STATISTICS_BROADCAST_FRAMES_RCV_SUPPORTED,
    NET_ADAPTER_STATISTICS_RCV_CRC_ERROR = NDIS_STATISTICS_RCV_CRC_ERROR_SUPPORTED,
    NET_ADAPTER_STATISTICS_TRANSMIT_QUEUE_LENGTH = NDIS_STATISTICS_TRANSMIT_QUEUE_LENGTH_SUPPORTED,
    NET_ADAPTER_STATISTICS_BYTES_RCV = NDIS_STATISTICS_BYTES_RCV_SUPPORTED,
    NET_ADAPTER_STATISTICS_BYTES_XMIT = NDIS_STATISTICS_BYTES_XMIT_SUPPORTED,
    NET_ADAPTER_STATISTICS_RCV_DISCARDS = NDIS_STATISTICS_RCV_DISCARDS_SUPPORTED,
    NET_ADAPTER_STATISTICS_GEN_STATISTICS = NDIS_STATISTICS_GEN_STATISTICS_SUPPORTED,
    NET_ADAPTER_STATISTICS_XMIT_DISCARDS = NDIS_STATISTICS_XMIT_DISCARDS_SUPPORTED,
} NET_ADAPTER_STATISTICS_FLAGS;

typedef enum _NET_ADAPTER_POWER_FLAGS {
    NET_ADAPTER_POWER_WAKE_PACKET_INDICATION = NDIS_PM_WAKE_PACKET_INDICATION_SUPPORTED,
    NET_ADAPTER_POWER_SELECTIVE_SUSPEND = NDIS_PM_SELECTIVE_SUSPEND_SUPPORTED,
} NET_ADAPTER_POWER_FLAGS;

typedef enum _NET_ADAPTER_WAKE_PATTERN_FLAGS {
    NET_ADAPTER_WAKE_BITMAP_PATTERN = NDIS_PM_WOL_BITMAP_PATTERN_ENABLED,
    NET_ADAPTER_WAKE_MAGIC_PACKET = NDIS_PM_WOL_MAGIC_PACKET_ENABLED,
    NET_ADAPTER_WAKE_IPV4_TCP_SYN = NDIS_PM_WOL_IPV4_TCP_SYN_ENABLED,
    NET_ADAPTER_WAKE_IPV6_TCP_SYN = NDIS_PM_WOL_IPV6_TCP_SYN_ENABLED,
    NET_ADAPTER_WAKE_IPV4_DEST_ADDR_WILDCARD = NDIS_PM_WOL_IPV4_DEST_ADDR_WILDCARD_ENABLED,
    NET_ADAPTER_WAKE_IPV6_DEST_ADDR_WILDCARD = NDIS_PM_WOL_IPV6_DEST_ADDR_WILDCARD_ENABLED,
    NET_ADAPTER_WAKE_EAPOL_REQUEST_ID_MESSAGE = NDIS_PM_WOL_EAPOL_REQUEST_ID_MESSAGE_ENABLED,
} NET_ADAPTER_WAKE_PATTERN_FLAGS;

typedef enum _NET_ADAPTER_PROTOCOL_OFFLOADS_FLAGS {
    NET_ADAPTER_PROTOCOL_OFFLOAD_ARP = NDIS_PM_PROTOCOL_OFFLOAD_ARP_ENABLED,
    NET_ADAPTER_PROTOCOL_OFFLOAD_NS = NDIS_PM_PROTOCOL_OFFLOAD_NS_ENABLED,
    NET_ADAPTER_PROTOCOL_OFFLOAD_80211_RSN_REKEY = NDIS_PM_PROTOCOL_OFFLOAD_80211_RSN_REKEY_ENABLED,
} NET_ADAPTER_PROTOCOL_OFFLOADS_FLAGS;

typedef enum _NET_ADAPTER_WAKEUP_EVENTS_FLAGS {
    NET_ADAPTER_WAKE_ON_MEDIA_CONNECT = NDIS_PM_WAKE_ON_MEDIA_CONNECT_SUPPORTED,
    NET_ADAPTER_WAKE_ON_MEDIA_DISCONNECT = NDIS_PM_WAKE_ON_MEDIA_DISCONNECT_SUPPORTED,
} NET_ADAPTER_WAKEUP_EVENTS_FLAGS;

typedef enum _NET_ADAPTER_MEDIA_SPECIFIC_WAKEUP_EVENTS_FLAGS {
    NET_ADAPTER_WLAN_WAKE_ON_NLO_DISCOVERY = NDIS_WLAN_WAKE_ON_NLO_DISCOVERY_SUPPORTED,
    NET_ADAPTER_WLAN_WAKE_ON_AP_ASSOCIATION_LOST = NDIS_WLAN_WAKE_ON_AP_ASSOCIATION_LOST_SUPPORTED,
    NET_ADAPTER_WLAN_WAKE_ON_GTK_HANDSHAKE_ERROR = NDIS_WLAN_WAKE_ON_GTK_HANDSHAKE_ERROR_SUPPORTED,
    NET_ADAPTER_WLAN_WAKE_ON_4WAY_HANDSHAKE_REQUEST = NDIS_WLAN_WAKE_ON_4WAY_HANDSHAKE_REQUEST_SUPPORTED,
    NET_ADAPTER_WWAN_WAKE_ON_REGISTER_STATE = NDIS_WWAN_WAKE_ON_REGISTER_STATE_SUPPORTED,
    NET_ADAPTER_WWAN_WAKE_ON_SMS_RECEIVE = NDIS_WWAN_WAKE_ON_SMS_RECEIVE_SUPPORTED,
    NET_ADAPTER_WWAN_WAKE_ON_USSD_RECEIVE = NDIS_WWAN_WAKE_ON_USSD_RECEIVE_SUPPORTED,
    NET_ADAPTER_WWAN_WAKE_ON_PACKET_STATE = NDIS_WWAN_WAKE_ON_PACKET_STATE_SUPPORTED,
    NET_ADAPTER_WWAN_WAKE_ON_UICC_CHANGE = NDIS_WWAN_WAKE_ON_UICC_CHANGE_SUPPORTED,
} NET_ADAPTER_MEDIA_SPECIFIC_WAKEUP_EVENTS_FLAGS;

typedef enum _NET_ADAPTER_PAUSE_FUNCTIONS {
    NetAdapterPauseFunctionsUnsupported = NdisPauseFunctionsUnsupported,
    NetAdapterPauseFunctionsSendOnly = NdisPauseFunctionsSendOnly,
    NetAdapterPauseFunctionsReceiveOnly = NdisPauseFunctionsReceiveOnly,
    NetAdapterPauseFunctionsSendAndReceive = NdisPauseFunctionsSendAndReceive,
    NetAdapterPauseFunctionsUnknown = NdisPauseFunctionsUnknown,
} NET_ADAPTER_PAUSE_FUNCTIONS, *PNET_ADAPTER_PAUSE_FUNCTIONS;

typedef enum _NET_ADAPTER_AUTO_NEGOTIATION_FLAGS {
    NET_ADAPTER_AUTO_NEGOTIATION_NO_FLAGS = 0,
    NET_ADAPTER_LINK_STATE_XMIT_LINK_SPEED_AUTO_NEGOTIATED = NDIS_LINK_STATE_XMIT_LINK_SPEED_AUTO_NEGOTIATED,
    NET_ADAPTER_LINK_STATE_RCV_LINK_SPEED_AUTO_NEGOTIATED = NDIS_LINK_STATE_RCV_LINK_SPEED_AUTO_NEGOTIATED,
    NET_ADAPTER_LINK_STATE_DUPLEX_AUTO_NEGOTIATED = NDIS_LINK_STATE_DUPLEX_AUTO_NEGOTIATED,
    NET_ADAPTER_LINK_STATE_PAUSE_FUNCTIONS_AUTO_NEGOTIATED = NDIS_LINK_STATE_PAUSE_FUNCTIONS_AUTO_NEGOTIATED,
} NET_ADAPTER_AUTO_NEGOTIATION_FLAGS;

typedef enum _NET_MEMORY_MAPPING_REQUIREMENT {
    NetMemoryMappingRequirementNone = 0,
    NetMemoryMappingRequirementDmaMapped,
} NET_MEMORY_MAPPING_REQUIREMENT, *PNET_MEMORY_MAPPING_REQUIREMENT;



#include <NetReceiveScaling.h>

DEFINE_ENUM_FLAG_OPERATORS(NET_PACKET_FILTER_TYPES_FLAGS);
DEFINE_ENUM_FLAG_OPERATORS(NET_ADAPTER_STATISTICS_FLAGS);
DEFINE_ENUM_FLAG_OPERATORS(NET_ADAPTER_POWER_FLAGS);
DEFINE_ENUM_FLAG_OPERATORS(NET_ADAPTER_WAKE_PATTERN_FLAGS);
DEFINE_ENUM_FLAG_OPERATORS(NET_ADAPTER_PROTOCOL_OFFLOADS_FLAGS);
DEFINE_ENUM_FLAG_OPERATORS(NET_ADAPTER_WAKEUP_EVENTS_FLAGS);
DEFINE_ENUM_FLAG_OPERATORS(NET_ADAPTER_MEDIA_SPECIFIC_WAKEUP_EVENTS_FLAGS);
DEFINE_ENUM_FLAG_OPERATORS(NET_ADAPTER_PAUSE_FUNCTIONS);
DEFINE_ENUM_FLAG_OPERATORS(NET_ADAPTER_AUTO_NEGOTIATION_FLAGS);

typedef
_Function_class_(EVT_NET_ADAPTER_CREATE_TXQUEUE)
_IRQL_requires_same_
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
EVT_NET_ADAPTER_CREATE_TXQUEUE(
    _In_
    NETADAPTER Adapter,
    _Inout_
    PNETTXQUEUE_INIT TxQueueInit
    );

typedef EVT_NET_ADAPTER_CREATE_TXQUEUE *PFN_NET_ADAPTER_CREATE_TXQUEUE;

typedef
_Function_class_(EVT_NET_ADAPTER_CREATE_RXQUEUE)
_IRQL_requires_same_
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
EVT_NET_ADAPTER_CREATE_RXQUEUE(
    _In_
    NETADAPTER Adapter,
    _Inout_
    PNETRXQUEUE_INIT RxQueueInit
    );

typedef EVT_NET_ADAPTER_CREATE_RXQUEUE *PFN_NET_ADAPTER_CREATE_RXQUEUE;

typedef NDIS_IF_PHYSICAL_ADDRESS NET_ADAPTER_LINK_LAYER_ADDRESS, *PNET_ADAPTER_LINK_LAYER_ADDRESS;

FORCEINLINE
VOID
NET_ADAPTER_LINK_LAYER_ADDRESS_INIT(
    _Out_                                      PNET_ADAPTER_LINK_LAYER_ADDRESS LinkLayerAddress,
    _In_range_(1,NDIS_MAX_PHYS_ADDRESS_LENGTH) USHORT                          Length,
    _In_reads_bytes_(Length)                   PCUCHAR                         AddressBuffer
    )
{
    RtlZeroMemory(LinkLayerAddress, sizeof(NET_ADAPTER_LINK_LAYER_ADDRESS));
    NT_ASSERTMSG("Failed: 0 < Length <= NDIS_MAX_PHYS_ADDRESS_LENGTH",
                 (Length != 0) && (Length <= NDIS_MAX_PHYS_ADDRESS_LENGTH));
    LinkLayerAddress->Length = Length;

    RtlCopyMemory(LinkLayerAddress->Address,
                  AddressBuffer,
                  Length < sizeof(LinkLayerAddress->Address) ?
                    Length :
                    sizeof(LinkLayerAddress->Address));
}

typedef struct _NET_ADAPTER_LINK_LAYER_CAPABILITIES {
    //
    // Size of structure.
    //
    ULONG                           Size;
    NET_PACKET_FILTER_TYPES_FLAGS   SupportedPacketFilters;
    ULONG                           MaxMulticastListSize;
    NET_ADAPTER_STATISTICS_FLAGS    SupportedStatistics;
    ULONG64                         MaxTxLinkSpeed;
    ULONG64                         MaxRxLinkSpeed;
} NET_ADAPTER_LINK_LAYER_CAPABILITIES, *PNET_ADAPTER_LINK_LAYER_CAPABILITIES;

FORCEINLINE
VOID
NET_ADAPTER_LINK_LAYER_CAPABILITIES_INIT(
    _Out_ PNET_ADAPTER_LINK_LAYER_CAPABILITIES  LinkLayerCapabilities,
    _In_  NET_PACKET_FILTER_TYPES_FLAGS  SupportedPacketFilters,
    _In_  ULONG                          MaxMulticastListSize,
    _In_  NET_ADAPTER_STATISTICS_FLAGS   SupportedStatistics,
    _In_  ULONG64                        MaxTxLinkSpeed,
    _In_  ULONG64                        MaxRxLinkSpeed
    )
{
    RtlZeroMemory(LinkLayerCapabilities, sizeof(NET_ADAPTER_LINK_LAYER_CAPABILITIES));
    LinkLayerCapabilities->Size = sizeof(NET_ADAPTER_LINK_LAYER_CAPABILITIES);
    LinkLayerCapabilities->SupportedPacketFilters = SupportedPacketFilters;
    LinkLayerCapabilities->MaxMulticastListSize = MaxMulticastListSize;
    LinkLayerCapabilities->SupportedStatistics = SupportedStatistics;
    LinkLayerCapabilities->MaxTxLinkSpeed = MaxTxLinkSpeed;
    LinkLayerCapabilities->MaxRxLinkSpeed = MaxRxLinkSpeed;
}

typedef
_Function_class_(EVT_NET_ADAPTER_PREVIEW_WAKE_PATTERN)
_IRQL_requires_same_
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
EVT_NET_ADAPTER_PREVIEW_WAKE_PATTERN(
    _In_
    NETADAPTER                      Adapter,
    _In_
    NETPOWERSETTINGS                ExistingPowerSettings,
    _In_
    NDIS_PM_WOL_PACKET              WakePatternType,
    _In_
    PNDIS_PM_WOL_PATTERN            PatternToBeAdded
    );

typedef EVT_NET_ADAPTER_PREVIEW_WAKE_PATTERN *PFN_NET_ADAPTER_PREVIEW_WAKE_PATTERN;

typedef
_Function_class_(EVT_NET_ADAPTER_PREVIEW_PROTOCOL_OFFLOAD)
_IRQL_requires_same_
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
EVT_NET_ADAPTER_PREVIEW_PROTOCOL_OFFLOAD(
    _In_
    NETADAPTER                          Adapter,
    _In_
    NETPOWERSETTINGS                    ExistingPowerSettings,
    _In_
    NDIS_PM_PROTOCOL_OFFLOAD_TYPE       ProtocolOffloadType,
    _In_
    PNDIS_PM_PROTOCOL_OFFLOAD           ProtocolOffloadToBeAdded
    );

typedef EVT_NET_ADAPTER_PREVIEW_PROTOCOL_OFFLOAD *PFN_NET_ADAPTER_PREVIEW_PROTOCOL_OFFLOAD;

typedef
_Function_class_(EVT_NET_ADAPTER_RETURN_RX_BUFFER)
_IRQL_requires_same_
_IRQL_requires_min_(PASSIVE_LEVEL)
_IRQL_requires_max_(DISPATCH_LEVEL)
VOID
EVT_NET_ADAPTER_RETURN_RX_BUFFER(
    _In_
    NETADAPTER  Adapter,
    _In_
    PVOID       RxBufferVirtualAddress,
    _In_
    PVOID       RxBufferReturnContext
    );

typedef EVT_NET_ADAPTER_RETURN_RX_BUFFER *PFN_NET_ADAPTER_RETURN_RX_BUFFER;

typedef struct _NET_ADAPTER_POWER_CAPABILITIES {
    //
    // Size of structure.
    //
    ULONG Size;
    NET_ADAPTER_POWER_FLAGS                        Flags;
    NET_ADAPTER_WAKE_PATTERN_FLAGS                 SupportedWakePatterns;
    ULONG                                          NumTotalWakePatterns;
    ULONG                                          MaxWakePatternSize;
    ULONG                                          MaxWakePatternOffset;
    ULONG                                          MaxWakePacketSaveBuffer;
    NET_ADAPTER_PROTOCOL_OFFLOADS_FLAGS            SupportedProtocolOffloads;
    ULONG                                          NumArpOffloadIPv4Addresses;
    ULONG                                          NumNSOffloadIPv6Addresses;
    NET_ADAPTER_WAKEUP_EVENTS_FLAGS                SupportedWakeUpEvents;
    NET_ADAPTER_MEDIA_SPECIFIC_WAKEUP_EVENTS_FLAGS SupportedMediaSpecificWakeUpEvents;
    PFN_NET_ADAPTER_PREVIEW_WAKE_PATTERN           EvtAdapterPreviewWakePattern;
    PFN_NET_ADAPTER_PREVIEW_PROTOCOL_OFFLOAD       EvtAdapterPreviewProtocolOffload;
    WDF_TRI_STATE                                  ManageS0IdlePowerReferences;
} NET_ADAPTER_POWER_CAPABILITIES, *PNET_ADAPTER_POWER_CAPABILITIES;

FORCEINLINE
VOID
NET_ADAPTER_POWER_CAPABILITIES_INIT(
    _Out_ PNET_ADAPTER_POWER_CAPABILITIES                PowerCapabilities
    )
{
    RtlZeroMemory(PowerCapabilities, sizeof(NET_ADAPTER_POWER_CAPABILITIES));
    PowerCapabilities->Size = sizeof(NET_ADAPTER_POWER_CAPABILITIES);
    PowerCapabilities->ManageS0IdlePowerReferences = WdfUseDefault;
}

#define NET_ADAPTER_FRAGMENT_DEFAULT_ALIGNMENT 1 //byte aligned

typedef struct _NET_ADAPTER_DMA_CAPABILITIES
{
    ULONG Size;

    //
    // DMA Enabler used by the adapter driver to map/allocate
    // memory
    //
    WDFDMAENABLER DmaEnabler;

    //
    // Maximum physical address to use when allocating buffers,
    // or 0 to indicate there is no maximum address
    //
    PHYSICAL_ADDRESS MaximumPhysicalAddress;

    //
    // Value defining if the memory allocated should have
    // cache enabled or not. WdfDefault will enable cache
    // only if the device is considered cache coherent by HAL
    //
    WDF_TRI_STATE CacheEnabled;

    //
    // Preferred NUMA node to use when allocating memory. If
    // this is MM_ANY_NODE_OK NetAdapterCx will query HAL for
    // closest node
    //
    NODE_REQUIREMENT PreferredNode;

} NET_ADAPTER_DMA_CAPABILITIES, *PNET_ADAPTER_DMA_CAPABILITIES;

FORCEINLINE
VOID
NET_ADAPTER_DMA_CAPABILITIES_INIT(
    _Out_ PNET_ADAPTER_DMA_CAPABILITIES DmaCapabilities,
    _In_ WDFDMAENABLER DmaEnabler
    )
{
    RtlZeroMemory(DmaCapabilities, sizeof(NET_ADAPTER_DMA_CAPABILITIES));
    DmaCapabilities->Size = sizeof(NET_ADAPTER_DMA_CAPABILITIES);
    DmaCapabilities->DmaEnabler = DmaEnabler;
    DmaCapabilities->CacheEnabled = WdfUseDefault;
    DmaCapabilities->PreferredNode = MM_ANY_NODE_OK;
}

typedef enum _NET_RX_FRAGMENT_BUFFER_ALLOCATION_MODE
{
    //
    // The operating system allocates receive fragment buffers on behalf
    // of the client driver.
    //
    NetRxFragmentBufferAllocationModeSystem = 0,

    //
    // The operating system never allocates receive fragment buffers.
    // It's the client driver's reponsiblity to so do.
    //
    NetRxFragmentBufferAllocationModeDriver,
} NET_RX_FRAGMENT_BUFFER_ALLOCATION_MODE;

typedef enum _NET_RX_FRAGMENT_BUFFER_ATTACHMENT_MODE
{
    //
    // The operating system attaches Rx fragment buffers to NET_PACKETs
    // automatically. It's only valid when Rx buffer allocation
    // is also set to System
    //
    //
    NetRxFragmentBufferAttachmentModeSystem = 0,

    //
    // It's the client driver's responsbility to attach Rx fragment
    // buffers to NET_PACKETs.
    //
    NetRxFragmentBufferAttachmentModeDriver,
} NET_RX_FRAGMENT_BUFFER_ATTACHMENT_MODE;

typedef struct _NET_ADAPTER_RX_CAPABILITIES
{
    ULONG Size;

    //
    // Specifies how the operating system should allocate receive buffers
    //
    NET_RX_FRAGMENT_BUFFER_ALLOCATION_MODE AllocationMode;

    //
    // Specifies how the operating system should pre-attach receive buffers
    //
    NET_RX_FRAGMENT_BUFFER_ATTACHMENT_MODE AttachmentMode;

    //
    // Hint indicating how many elements the adapter
    // wants per Rx queue's NET_PACKET_FRAGMENT ring buffer.
    // It must be power of 2
    //
    UINT32 FragmentRingNumberOfElementsHint;

    //
    // Maximum fragment size in byte the adapter can receive
    //
    SIZE_T MaximumFragmentBufferSize;

    //
    // Maximum number of receive queues the adapter supports
    //
    SIZE_T MaximumNumberOfQueues;

    union
    {
        //
        // if AllocationMode is NetRxFragmentBufferAllocationModeDriver, the driver
        // must provide a callback function for the operating system to invoke once
        // the operating system is done with the rx buffer
        //
        struct
        {
            PFN_NET_ADAPTER_RETURN_RX_BUFFER EvtAdapterReturnRxBuffer;
        }
        DUMMYSTRUCTNAME;

        //
        // if AllocationMode is NetRxFragmentBufferAllocationModeAutomatic or
        // NetRxFragmentBufferAllocationModeManual, the driver must specify
        // the following fields to let the operating system know how to allocate
        // the Rx buffer
        //
        struct
        {
            //
            // Specifies how the operating system should map receive data buffers
            //
            NET_MEMORY_MAPPING_REQUIREMENT MappingRequirement;

            //
            // Minimum fragment alignment
            // It must be power of 2
            //
            SIZE_T FragmentBufferAlignment;

            //
            // Points to a struct describing the adapter's
            // DMA capabilities on the receive path. Ignored if
            // MappingRequirement is not NetMemoryMappingRequirementDmaMapped
            //
            PNET_ADAPTER_DMA_CAPABILITIES DmaCapabilities;
        }
        DUMMYSTRUCTNAME2;
    }
    DUMMYUNIONNAME;

} NET_ADAPTER_RX_CAPABILITIES, *PNET_ADAPTER_RX_CAPABILITIES;

FORCEINLINE
VOID
NET_ADAPTER_RX_CAPABILITIES_INIT_DRIVER_MANAGED(
    _Out_ PNET_ADAPTER_RX_CAPABILITIES RxCapabilities,
    _In_ PFN_NET_ADAPTER_RETURN_RX_BUFFER EvtAdapterReturnRxBuffer,
    _In_ SIZE_T MaximumFragmentBufferSize,
    _In_ SIZE_T MaximumNumberOfQueues
    )
{
    RtlZeroMemory(RxCapabilities, sizeof(NET_ADAPTER_RX_CAPABILITIES));
    RxCapabilities->Size = sizeof(NET_ADAPTER_RX_CAPABILITIES);
    RxCapabilities->FragmentBufferAlignment = NET_ADAPTER_FRAGMENT_DEFAULT_ALIGNMENT;
    RxCapabilities->MaximumFragmentBufferSize = MaximumFragmentBufferSize;
    RxCapabilities->MaximumNumberOfQueues = MaximumNumberOfQueues;

    RxCapabilities->AllocationMode = NetRxFragmentBufferAllocationModeDriver;
    RxCapabilities->AttachmentMode = NetRxFragmentBufferAttachmentModeDriver;
    RxCapabilities->EvtAdapterReturnRxBuffer = EvtAdapterReturnRxBuffer;
}

FORCEINLINE
VOID
NET_ADAPTER_RX_CAPABILITIES_INIT_SYSTEM_MANAGED(
    _Out_ PNET_ADAPTER_RX_CAPABILITIES RxCapabilities,
    _In_ SIZE_T MaximumFragmentBufferSize,
    _In_ SIZE_T MaximumNumberOfQueues
    )
{
    RtlZeroMemory(RxCapabilities, sizeof(NET_ADAPTER_RX_CAPABILITIES));
    RxCapabilities->Size = sizeof(NET_ADAPTER_RX_CAPABILITIES);
    RxCapabilities->FragmentBufferAlignment = NET_ADAPTER_FRAGMENT_DEFAULT_ALIGNMENT;
    RxCapabilities->MaximumFragmentBufferSize = MaximumFragmentBufferSize;
    RxCapabilities->MaximumNumberOfQueues = MaximumNumberOfQueues;

    RxCapabilities->AllocationMode = NetRxFragmentBufferAllocationModeSystem;
    RxCapabilities->AttachmentMode = NetRxFragmentBufferAttachmentModeSystem;
    RxCapabilities->MappingRequirement = NetMemoryMappingRequirementNone;
}

FORCEINLINE
VOID
NET_ADAPTER_RX_CAPABILITIES_INIT_SYSTEM_MANAGED_DMA(
    _Out_ PNET_ADAPTER_RX_CAPABILITIES RxCapabilities,
    _In_ PNET_ADAPTER_DMA_CAPABILITIES DmaCapabilities,
    _In_ SIZE_T MaximumFragmentBufferSize,
    _In_ SIZE_T MaximumNumberOfQueues
    )
{
    RtlZeroMemory(RxCapabilities, sizeof(NET_ADAPTER_RX_CAPABILITIES));
    RxCapabilities->Size = sizeof(NET_ADAPTER_RX_CAPABILITIES);
    RxCapabilities->FragmentBufferAlignment = NET_ADAPTER_FRAGMENT_DEFAULT_ALIGNMENT;
    RxCapabilities->MaximumFragmentBufferSize = MaximumFragmentBufferSize;
    RxCapabilities->MaximumNumberOfQueues = MaximumNumberOfQueues;

    RxCapabilities->AllocationMode = NetRxFragmentBufferAllocationModeSystem;
    RxCapabilities->AttachmentMode = NetRxFragmentBufferAttachmentModeSystem;
    RxCapabilities->MappingRequirement = NetMemoryMappingRequirementDmaMapped;
    RxCapabilities->DmaCapabilities = DmaCapabilities;
}

typedef struct _NET_ADAPTER_TX_CAPABILITIES
{
    ULONG Size;

    //
    // Specifies how the operating system should map transmit data buffers
    //
    NET_MEMORY_MAPPING_REQUIREMENT MappingRequirement;

    //
    // Maximum data buffer size the adapter can transmit
    //
    SIZE_T MaximumFragmentBufferSize;

    //
    // Amount of space in bytes reserved for the client driver before the start
    // of a NET_PACKET's payload
    //
    SIZE_T PayloadBackfill;

    //
    // Maximum number of fragments per packet the adapter
    // can handle, or ((SIZE_T) -1) if there is no limit
    //
    SIZE_T MaximumNumberOfFragments;

    //
    // Minimum fragment alignment
    // It must be power of 2
    //
    SIZE_T FragmentBufferAlignment;

    //
    // Hint indicating how many elements the adapter
    // wants per Tx queue's NET_PACKET_FRAGMENT ring buffer
    // It must be power of 2
    //
    UINT32 FragmentRingNumberOfElementsHint;

    //
    // Maximum number of transmit queues the adapter supports.
    //
    SIZE_T MaximumNumberOfQueues;

    //
    // Points to a struct describing the adapter's
    // DMA capabilities on the transmit path. Ignored
    // if MappingRequirement is not NetMemoryMappingRequirementDmaMapped
    //
    PNET_ADAPTER_DMA_CAPABILITIES DmaCapabilities;

} NET_ADAPTER_TX_CAPABILITIES, *PNET_ADAPTER_TX_CAPABILITIES;

FORCEINLINE
VOID
NET_ADAPTER_TX_CAPABILITIES_INIT(
    _Out_ PNET_ADAPTER_TX_CAPABILITIES TxCapabilities,
    _In_ SIZE_T MaximumFragmentBufferSize,
    _In_ SIZE_T MaximumNumberOfQueues
    )
{
    RtlZeroMemory(TxCapabilities, sizeof(NET_ADAPTER_TX_CAPABILITIES));
    TxCapabilities->Size = sizeof(NET_ADAPTER_TX_CAPABILITIES);
    TxCapabilities->FragmentBufferAlignment = NET_ADAPTER_FRAGMENT_DEFAULT_ALIGNMENT;
    TxCapabilities->MaximumFragmentBufferSize = MaximumFragmentBufferSize;
    TxCapabilities->MaximumNumberOfQueues = MaximumNumberOfQueues;
    TxCapabilities->MaximumNumberOfFragments = (SIZE_T)-1;
}

FORCEINLINE
VOID
NET_ADAPTER_TX_CAPABILITIES_INIT_FOR_DMA(
    _Out_ PNET_ADAPTER_TX_CAPABILITIES TxCapabilities,
    _In_ PNET_ADAPTER_DMA_CAPABILITIES DmaCapabilities,
    _In_ SIZE_T MaximumFragmentBufferSize,
    _In_ SIZE_T MaximumNumberOfQueues
    )
{
    NET_ADAPTER_TX_CAPABILITIES_INIT(
        TxCapabilities,
        MaximumFragmentBufferSize,
        MaximumNumberOfQueues);

    TxCapabilities->DmaCapabilities = DmaCapabilities;
    TxCapabilities->MappingRequirement = NetMemoryMappingRequirementDmaMapped;
}

typedef struct _NET_ADAPTER_LINK_STATE {
    //
    // Size of structure.
    //
    ULONG                                Size;

    //
    // The Tranmit and Recieve Link Speeds of the adapter
    // in bits per second.
    //
    ULONG64                              TxLinkSpeed;
    ULONG64                              RxLinkSpeed;

    //
    // Media Connect state of the adapter
    //
    NET_IF_MEDIA_CONNECT_STATE           MediaConnectState;

    //
    // Media duplex state of the adapter
    //
    NET_IF_MEDIA_DUPLEX_STATE            MediaDuplexState;

    //
    // Supported pause functions by the adapter
    //
    NET_ADAPTER_PAUSE_FUNCTIONS          SupportedPauseFunctions;

    //
    // Flags representing the auto-negotiation settings of the adapter
    //
    NET_ADAPTER_AUTO_NEGOTIATION_FLAGS   AutoNegotiationFlags;

} NET_ADAPTER_LINK_STATE, *PNET_ADAPTER_LINK_STATE;

FORCEINLINE
VOID
NET_ADAPTER_LINK_STATE_INIT(
    _Out_ PNET_ADAPTER_LINK_STATE              LinkState,
    _In_  ULONG64                              LinkSpeed,
    _In_  NET_IF_MEDIA_CONNECT_STATE           MediaConnectState,
    _In_  NET_IF_MEDIA_DUPLEX_STATE            MediaDuplexState,
    _In_  NET_ADAPTER_PAUSE_FUNCTIONS          SupportedPauseFunctions,
    _In_  NET_ADAPTER_AUTO_NEGOTIATION_FLAGS   AutoNegotiationFlags
    )
{
    RtlZeroMemory(LinkState, sizeof(NET_ADAPTER_LINK_STATE));
    LinkState->Size = sizeof(NET_ADAPTER_LINK_STATE);
    LinkState->TxLinkSpeed = LinkSpeed;
    LinkState->RxLinkSpeed = LinkSpeed;
    LinkState->MediaConnectState = MediaConnectState;
    LinkState->MediaDuplexState = MediaDuplexState;
    LinkState->SupportedPauseFunctions = SupportedPauseFunctions;
    LinkState->AutoNegotiationFlags = AutoNegotiationFlags;
}

FORCEINLINE
VOID
NET_ADAPTER_LINK_STATE_INIT_DISCONNECTED(
    _Out_ PNET_ADAPTER_LINK_STATE              LinkState
    )
{
    RtlZeroMemory(LinkState, sizeof(NET_ADAPTER_LINK_STATE));
    LinkState->Size = sizeof(NET_ADAPTER_LINK_STATE);

    LinkState->MediaConnectState = MediaConnectStateDisconnected;

    LinkState->TxLinkSpeed = NDIS_LINK_SPEED_UNKNOWN;
    LinkState->RxLinkSpeed = NDIS_LINK_SPEED_UNKNOWN;
    LinkState->MediaDuplexState = MediaDuplexStateUnknown;
    LinkState->SupportedPauseFunctions = NetAdapterPauseFunctionsUnknown;
    LinkState->AutoNegotiationFlags = NET_ADAPTER_AUTO_NEGOTIATION_NO_FLAGS;
}

typedef struct _NET_ADAPTER_DATAPATH_CALLBACKS {
    //
    // Size of structure.
    //
    ULONG                                     Size;

    PFN_NET_ADAPTER_CREATE_TXQUEUE            EvtAdapterCreateTxQueue;
    PFN_NET_ADAPTER_CREATE_RXQUEUE            EvtAdapterCreateRxQueue;

} NET_ADAPTER_DATAPATH_CALLBACKS, *PNET_ADAPTER_DATAPATH_CALLBACKS;

FORCEINLINE
VOID
NET_ADAPTER_DATAPATH_CALLBACKS_INIT(
    _Out_ PNET_ADAPTER_DATAPATH_CALLBACKS         DatapathCallbacks,
    _In_  PFN_NET_ADAPTER_CREATE_TXQUEUE          EvtAdapterCreateTxQueue,
    _In_  PFN_NET_ADAPTER_CREATE_RXQUEUE          EvtAdapterCreateRxQueue
    )
{
    RtlZeroMemory(DatapathCallbacks,
        sizeof(NET_ADAPTER_DATAPATH_CALLBACKS));
    DatapathCallbacks->Size = sizeof(NET_ADAPTER_DATAPATH_CALLBACKS);
    DatapathCallbacks->EvtAdapterCreateTxQueue = EvtAdapterCreateTxQueue;
    DatapathCallbacks->EvtAdapterCreateRxQueue = EvtAdapterCreateRxQueue;
}

typedef struct _NET_ADAPTER_OFFLOAD_CHECKSUM_CAPABILITIES
{
    //
    // Size of structure
    //
    ULONG Size;

    //
    // Flag specifying whether the hardware can calculate and validate IPv4 checksum
    //
    BOOLEAN IPv4;

    //
    // Flag specifying whether the hardware can calculate and validate Tcp checksum
    //
    BOOLEAN Tcp;

    //
    // Flag specifying whether the hardware can calculate and validate Udp checksum
    //
    BOOLEAN Udp;

} NET_ADAPTER_OFFLOAD_CHECKSUM_CAPABILITIES, *PNET_ADAPTER_OFFLOAD_CHECKSUM_CAPABILITIES;

FORCEINLINE
VOID
NET_ADAPTER_OFFLOAD_CHECKSUM_CAPABILITIES_INIT(
    _Out_ PNET_ADAPTER_OFFLOAD_CHECKSUM_CAPABILITIES ChecksumCapabilities,
    _In_  BOOLEAN IPv4,
    _In_  BOOLEAN Tcp,
    _In_  BOOLEAN Udp
)
{
    RtlZeroMemory(ChecksumCapabilities, sizeof(NET_ADAPTER_OFFLOAD_CHECKSUM_CAPABILITIES));
    ChecksumCapabilities->Size = sizeof(NET_ADAPTER_OFFLOAD_CHECKSUM_CAPABILITIES);

    ChecksumCapabilities->IPv4 = IPv4;
    ChecksumCapabilities->Tcp = Tcp;
    ChecksumCapabilities->Udp = Udp;
}

typedef
_Function_class_(EVT_NET_ADAPTER_OFFLOAD_SET_CHECKSUM)
_IRQL_requires_same_
_IRQL_requires_max_(PASSIVE_LEVEL)
VOID
EVT_NET_ADAPTER_OFFLOAD_SET_CHECKSUM(
    _In_
    NETADAPTER Adapter,
    _In_
    PNET_ADAPTER_OFFLOAD_CHECKSUM_CAPABILITIES ActiveCapabilities
    );

typedef EVT_NET_ADAPTER_OFFLOAD_SET_CHECKSUM *PFN_NET_ADAPTER_OFFLOAD_SET_CHECKSUM;

typedef struct _NET_ADAPTER_OFFLOAD_LSO_CAPABILITIES
{
    //
    // Size of structure
    //
    ULONG Size;

    //
    // Flag specifying whether NIC can segment a large TCP on IPv4
    //
    BOOLEAN IPv4;

    //
    // Flag specifying whether NIC can segment a large TCP on IPv6
    //
    BOOLEAN IPv6;

    //
    // Maximum bytes of user data that the transport can pass
    // to the miniport driver in a single packet
    //
    SIZE_T MaximumOffloadSize;

    //
    // Minimum number of segments that a large TCP packet must be divisible by
    // before the transport can offload it to the hardware for segmentation
    //
    SIZE_T MinimumSegmentCount;

} NET_ADAPTER_OFFLOAD_LSO_CAPABILITIES, *PNET_ADAPTER_OFFLOAD_LSO_CAPABILITIES; 


FORCEINLINE
VOID
NET_ADAPTER_OFFLOAD_LSO_CAPABILITIES_INIT(
    _Out_ PNET_ADAPTER_OFFLOAD_LSO_CAPABILITIES LsoCapabilities,
    _In_ BOOLEAN IPv4,
    _In_ BOOLEAN IPv6,
    _In_ SIZE_T MaximumOffloadSize,
    _In_ SIZE_T MinimumSegmentCount
)
{
    RtlZeroMemory(LsoCapabilities, sizeof(NET_ADAPTER_OFFLOAD_LSO_CAPABILITIES));
    LsoCapabilities->Size = sizeof(NET_ADAPTER_OFFLOAD_LSO_CAPABILITIES);

    LsoCapabilities->IPv4 = IPv4;
    LsoCapabilities->IPv6 = IPv6;
    LsoCapabilities->MaximumOffloadSize = MaximumOffloadSize;
    LsoCapabilities->MinimumSegmentCount = MinimumSegmentCount;
}

typedef
_Function_class_(EVT_NET_ADAPTER_OFFLOAD_SET_LSO)
_IRQL_requires_same_
_IRQL_requires_max_(PASSIVE_LEVEL)
VOID
EVT_NET_ADAPTER_OFFLOAD_SET_LSO(
    _In_
    NETADAPTER Adapter,
    _In_
    PNET_ADAPTER_OFFLOAD_LSO_CAPABILITIES ActiveCapabilities
    );

typedef EVT_NET_ADAPTER_OFFLOAD_SET_LSO *PFN_NET_ADAPTER_OFFLOAD_SET_LSO;


//
// NET Function: NetDefaultAdapterInitAllocate
//
typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
WDFAPI
PNETADAPTER_INIT
(*PFN_NETDEFAULTADAPTERINITALLOCATE)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _In_
    WDFDEVICE Device
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
PNETADAPTER_INIT
FORCEINLINE
NetDefaultAdapterInitAllocate(
    _In_
    WDFDEVICE Device
    )
{
    return ((PFN_NETDEFAULTADAPTERINITALLOCATE) NetFunctions[NetDefaultAdapterInitAllocateTableIndex])(NetDriverGlobals, Device);
}

//
// NET Function: NetAdapterInitAllocate
//
typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
WDFAPI
PNETADAPTER_INIT
(*PFN_NETADAPTERINITALLOCATE)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _In_
    WDFDEVICE Device
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
PNETADAPTER_INIT
FORCEINLINE
NetAdapterInitAllocate(
    _In_
    WDFDEVICE Device
    )
{
    return ((PFN_NETADAPTERINITALLOCATE) NetFunctions[NetAdapterInitAllocateTableIndex])(NetDriverGlobals, Device);
}

//
// NET Function: NetAdapterInitFree
//
typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
WDFAPI
VOID
(*PFN_NETADAPTERINITFREE)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _In_
    PNETADAPTER_INIT AdapterInit
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
VOID
FORCEINLINE
NetAdapterInitFree(
    _In_
    PNETADAPTER_INIT AdapterInit
    )
{
    ((PFN_NETADAPTERINITFREE) NetFunctions[NetAdapterInitFreeTableIndex])(NetDriverGlobals, AdapterInit);
}

//
// NET Function: NetAdapterInitSetDatapathCallbacks
//
typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
WDFAPI
VOID
(*PFN_NETADAPTERINITSETDATAPATHCALLBACKS)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _Inout_
    PNETADAPTER_INIT AdapterInit,
    _In_
    PNET_ADAPTER_DATAPATH_CALLBACKS DatapathCallbacks
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
VOID
FORCEINLINE
NetAdapterInitSetDatapathCallbacks(
    _Inout_
    PNETADAPTER_INIT AdapterInit,
    _In_
    PNET_ADAPTER_DATAPATH_CALLBACKS DatapathCallbacks
    )
{
    ((PFN_NETADAPTERINITSETDATAPATHCALLBACKS) NetFunctions[NetAdapterInitSetDatapathCallbacksTableIndex])(NetDriverGlobals, AdapterInit, DatapathCallbacks);
}

//
// NET Function: NetAdapterInitSetNetRequestAttributes
//
typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
WDFAPI
VOID
(*PFN_NETADAPTERINITSETNETREQUESTATTRIBUTES)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _Inout_
    PNETADAPTER_INIT AdapterInit,
    _In_
    PWDF_OBJECT_ATTRIBUTES NetRequestAttributes
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
VOID
FORCEINLINE
NetAdapterInitSetNetRequestAttributes(
    _Inout_
    PNETADAPTER_INIT AdapterInit,
    _In_
    PWDF_OBJECT_ATTRIBUTES NetRequestAttributes
    )
{
    ((PFN_NETADAPTERINITSETNETREQUESTATTRIBUTES) NetFunctions[NetAdapterInitSetNetRequestAttributesTableIndex])(NetDriverGlobals, AdapterInit, NetRequestAttributes);
}

//
// NET Function: NetAdapterInitSetNetPowerSettingsAttributes
//
typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
WDFAPI
VOID
(*PFN_NETADAPTERINITSETNETPOWERSETTINGSATTRIBUTES)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _Inout_
    PNETADAPTER_INIT AdapterInit,
    _In_
    PWDF_OBJECT_ATTRIBUTES NetPowerSettingsAttributes
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
VOID
FORCEINLINE
NetAdapterInitSetNetPowerSettingsAttributes(
    _Inout_
    PNETADAPTER_INIT AdapterInit,
    _In_
    PWDF_OBJECT_ATTRIBUTES NetPowerSettingsAttributes
    )
{
    ((PFN_NETADAPTERINITSETNETPOWERSETTINGSATTRIBUTES) NetFunctions[NetAdapterInitSetNetPowerSettingsAttributesTableIndex])(NetDriverGlobals, AdapterInit, NetPowerSettingsAttributes);
}

//
// NET Function: NetAdapterDeviceInitConfig
//
typedef
_Must_inspect_result_
_IRQL_requires_max_(PASSIVE_LEVEL)
WDFAPI
NTSTATUS
(*PFN_NETADAPTERDEVICEINITCONFIG)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _Inout_
    PWDFDEVICE_INIT DeviceInit
    );

_Must_inspect_result_
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
FORCEINLINE
NetAdapterDeviceInitConfig(
    _Inout_
    PWDFDEVICE_INIT DeviceInit
    )
{
    return ((PFN_NETADAPTERDEVICEINITCONFIG) NetFunctions[NetAdapterDeviceInitConfigTableIndex])(NetDriverGlobals, DeviceInit);
}

//
// NET Function: NetAdapterCreate
//
typedef
_Must_inspect_result_
_IRQL_requires_max_(PASSIVE_LEVEL)
WDFAPI
NTSTATUS
(*PFN_NETADAPTERCREATE)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _In_
    PNETADAPTER_INIT AdapterInit,
    _In_opt_
    PWDF_OBJECT_ATTRIBUTES AdapterAttributes,
    _Out_
    NETADAPTER* Adapter
    );

_Must_inspect_result_
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
FORCEINLINE
NetAdapterCreate(
    _In_
    PNETADAPTER_INIT AdapterInit,
    _In_opt_
    PWDF_OBJECT_ATTRIBUTES AdapterAttributes,
    _Out_
    NETADAPTER* Adapter
    )
{
    return ((PFN_NETADAPTERCREATE) NetFunctions[NetAdapterCreateTableIndex])(NetDriverGlobals, AdapterInit, AdapterAttributes, Adapter);
}

//
// NET Function: NetAdapterStart
//
typedef
_Must_inspect_result_
_IRQL_requires_max_(PASSIVE_LEVEL)
WDFAPI
NTSTATUS
(*PFN_NETADAPTERSTART)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _In_
    NETADAPTER Adapter
    );

_Must_inspect_result_
_IRQL_requires_max_(PASSIVE_LEVEL)
NTSTATUS
FORCEINLINE
NetAdapterStart(
    _In_
    NETADAPTER Adapter
    )
{
    return ((PFN_NETADAPTERSTART) NetFunctions[NetAdapterStartTableIndex])(NetDriverGlobals, Adapter);
}

//
// NET Function: NetAdapterStop
//
typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
WDFAPI
VOID
(*PFN_NETADAPTERSTOP)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _In_
    NETADAPTER Adapter
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
VOID
FORCEINLINE
NetAdapterStop(
    _In_
    NETADAPTER Adapter
    )
{
    ((PFN_NETADAPTERSTOP) NetFunctions[NetAdapterStopTableIndex])(NetDriverGlobals, Adapter);
}

//
// NET Function: NetAdapterSetLinkLayerCapabilities
//
typedef
_IRQL_requires_(PASSIVE_LEVEL)
WDFAPI
VOID
(*PFN_NETADAPTERSETLINKLAYERCAPABILITIES)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _In_
    NETADAPTER Adapter,
    _In_
    PNET_ADAPTER_LINK_LAYER_CAPABILITIES LinkLayerCapabilities
    );

_IRQL_requires_(PASSIVE_LEVEL)
VOID
FORCEINLINE
NetAdapterSetLinkLayerCapabilities(
    _In_
    NETADAPTER Adapter,
    _In_
    PNET_ADAPTER_LINK_LAYER_CAPABILITIES LinkLayerCapabilities
    )
{
    ((PFN_NETADAPTERSETLINKLAYERCAPABILITIES) NetFunctions[NetAdapterSetLinkLayerCapabilitiesTableIndex])(NetDriverGlobals, Adapter, LinkLayerCapabilities);
}

//
// NET Function: NetAdapterSetLinkLayerMtuSize
//
typedef
_IRQL_requires_(PASSIVE_LEVEL)
WDFAPI
VOID
(*PFN_NETADAPTERSETLINKLAYERMTUSIZE)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _In_
    NETADAPTER Adapter,
    _In_
    ULONG MtuSize
    );

_IRQL_requires_(PASSIVE_LEVEL)
VOID
FORCEINLINE
NetAdapterSetLinkLayerMtuSize(
    _In_
    NETADAPTER Adapter,
    _In_
    ULONG MtuSize
    )
{
    ((PFN_NETADAPTERSETLINKLAYERMTUSIZE) NetFunctions[NetAdapterSetLinkLayerMtuSizeTableIndex])(NetDriverGlobals, Adapter, MtuSize);
}

//
// NET Function: NetAdapterSetPowerCapabilities
//
typedef
_IRQL_requires_(PASSIVE_LEVEL)
WDFAPI
VOID
(*PFN_NETADAPTERSETPOWERCAPABILITIES)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _In_
    NETADAPTER Adapter,
    _In_
    PNET_ADAPTER_POWER_CAPABILITIES PowerCapabilities
    );

_IRQL_requires_(PASSIVE_LEVEL)
VOID
FORCEINLINE
NetAdapterSetPowerCapabilities(
    _In_
    NETADAPTER Adapter,
    _In_
    PNET_ADAPTER_POWER_CAPABILITIES PowerCapabilities
    )
{
    ((PFN_NETADAPTERSETPOWERCAPABILITIES) NetFunctions[NetAdapterSetPowerCapabilitiesTableIndex])(NetDriverGlobals, Adapter, PowerCapabilities);
}

//
// NET Function: NetAdapterSetDataPathCapabilities
//
typedef
_IRQL_requires_(PASSIVE_LEVEL)
WDFAPI
VOID
(*PFN_NETADAPTERSETDATAPATHCAPABILITIES)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _In_
    NETADAPTER Adapter,
    _In_
    PNET_ADAPTER_TX_CAPABILITIES TxCapabilities,
    _In_
    PNET_ADAPTER_RX_CAPABILITIES RxCapabilities
    );

_IRQL_requires_(PASSIVE_LEVEL)
VOID
FORCEINLINE
NetAdapterSetDataPathCapabilities(
    _In_
    NETADAPTER Adapter,
    _In_
    PNET_ADAPTER_TX_CAPABILITIES TxCapabilities,
    _In_
    PNET_ADAPTER_RX_CAPABILITIES RxCapabilities
    )
{
    ((PFN_NETADAPTERSETDATAPATHCAPABILITIES) NetFunctions[NetAdapterSetDataPathCapabilitiesTableIndex])(NetDriverGlobals, Adapter, TxCapabilities, RxCapabilities);
}

//
// NET Function: NetAdapterSetCurrentLinkState
//
typedef
_IRQL_requires_max_(DISPATCH_LEVEL)
WDFAPI
VOID
(*PFN_NETADAPTERSETCURRENTLINKSTATE)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _In_
    NETADAPTER Adapter,
    _In_
    PNET_ADAPTER_LINK_STATE CurrentLinkState
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
VOID
FORCEINLINE
NetAdapterSetCurrentLinkState(
    _In_
    NETADAPTER Adapter,
    _In_
    PNET_ADAPTER_LINK_STATE CurrentLinkState
    )
{
    ((PFN_NETADAPTERSETCURRENTLINKSTATE) NetFunctions[NetAdapterSetCurrentLinkStateTableIndex])(NetDriverGlobals, Adapter, CurrentLinkState);
}

//
// NET Function: NetAdapterWdmGetNdisHandle
//
typedef
WDFAPI
NDIS_HANDLE
(*PFN_NETADAPTERWDMGETNDISHANDLE)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _In_
    NETADAPTER Adapter
    );

NDIS_HANDLE
FORCEINLINE
NetAdapterWdmGetNdisHandle(
    _In_
    NETADAPTER Adapter
    )
{
    return ((PFN_NETADAPTERWDMGETNDISHANDLE) NetFunctions[NetAdapterWdmGetNdisHandleTableIndex])(NetDriverGlobals, Adapter);
}

//
// NET Function: NetAdapterGetNetLuid
//
typedef
_IRQL_requires_(PASSIVE_LEVEL)
WDFAPI
NET_LUID
(*PFN_NETADAPTERGETNETLUID)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _In_
    NETADAPTER Adapter
    );

_IRQL_requires_(PASSIVE_LEVEL)
NET_LUID
FORCEINLINE
NetAdapterGetNetLuid(
    _In_
    NETADAPTER Adapter
    )
{
    return ((PFN_NETADAPTERGETNETLUID) NetFunctions[NetAdapterGetNetLuidTableIndex])(NetDriverGlobals, Adapter);
}

//
// NET Function: NetAdapterOpenConfiguration
//
typedef
_Must_inspect_result_
_IRQL_requires_(PASSIVE_LEVEL)
WDFAPI
NTSTATUS
(*PFN_NETADAPTEROPENCONFIGURATION)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _In_
    NETADAPTER Adapter,
    _In_opt_
    PWDF_OBJECT_ATTRIBUTES ConfigurationAttributes,
    _Out_
    NETCONFIGURATION* Configuration
    );

_Must_inspect_result_
_IRQL_requires_(PASSIVE_LEVEL)
NTSTATUS
FORCEINLINE
NetAdapterOpenConfiguration(
    _In_
    NETADAPTER Adapter,
    _In_opt_
    PWDF_OBJECT_ATTRIBUTES ConfigurationAttributes,
    _Out_
    NETCONFIGURATION* Configuration
    )
{
    return ((PFN_NETADAPTEROPENCONFIGURATION) NetFunctions[NetAdapterOpenConfigurationTableIndex])(NetDriverGlobals, Adapter, ConfigurationAttributes, Configuration);
}

//
// NET Function: NetAdapterGetPowerSettings
//
typedef
_IRQL_requires_max_(DISPATCH_LEVEL)
WDFAPI
NETPOWERSETTINGS
(*PFN_NETADAPTERGETPOWERSETTINGS)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _In_
    NETADAPTER Adapter
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
NETPOWERSETTINGS
FORCEINLINE
NetAdapterGetPowerSettings(
    _In_
    NETADAPTER Adapter
    )
{
    return ((PFN_NETADAPTERGETPOWERSETTINGS) NetFunctions[NetAdapterGetPowerSettingsTableIndex])(NetDriverGlobals, Adapter);
}

//
// NET Function: NetAdapterDriverWdmGetHandle
//
typedef
_IRQL_requires_max_(DISPATCH_LEVEL)
WDFAPI
NDIS_HANDLE
(*PFN_NETADAPTERDRIVERWDMGETHANDLE)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _In_
    WDFDRIVER Driver
    );

_IRQL_requires_max_(DISPATCH_LEVEL)
NDIS_HANDLE
FORCEINLINE
NetAdapterDriverWdmGetHandle(
    _In_
    WDFDRIVER Driver
    )
{
    return ((PFN_NETADAPTERDRIVERWDMGETHANDLE) NetFunctions[NetAdapterDriverWdmGetHandleTableIndex])(NetDriverGlobals, Driver);
}

//
// NET Function: NetAdapterSetPermanentLinkLayerAddress
//
typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
WDFAPI
VOID
(*PFN_NETADAPTERSETPERMANENTLINKLAYERADDRESS)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _In_
    NETADAPTER Adapter,
    _In_
    PNET_ADAPTER_LINK_LAYER_ADDRESS LinkLayerAddress
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
VOID
FORCEINLINE
NetAdapterSetPermanentLinkLayerAddress(
    _In_
    NETADAPTER Adapter,
    _In_
    PNET_ADAPTER_LINK_LAYER_ADDRESS LinkLayerAddress
    )
{
    ((PFN_NETADAPTERSETPERMANENTLINKLAYERADDRESS) NetFunctions[NetAdapterSetPermanentLinkLayerAddressTableIndex])(NetDriverGlobals, Adapter, LinkLayerAddress);
}

//
// NET Function: NetAdapterSetCurrentLinkLayerAddress
//
typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
WDFAPI
VOID
(*PFN_NETADAPTERSETCURRENTLINKLAYERADDRESS)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _In_
    NETADAPTER Adapter,
    _In_
    PNET_ADAPTER_LINK_LAYER_ADDRESS LinkLayerAddress
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
VOID
FORCEINLINE
NetAdapterSetCurrentLinkLayerAddress(
    _In_
    NETADAPTER Adapter,
    _In_
    PNET_ADAPTER_LINK_LAYER_ADDRESS LinkLayerAddress
    )
{
    ((PFN_NETADAPTERSETCURRENTLINKLAYERADDRESS) NetFunctions[NetAdapterSetCurrentLinkLayerAddressTableIndex])(NetDriverGlobals, Adapter, LinkLayerAddress);
}

//
// NET Function: NetAdapterOffloadSetChecksumCapabilities
//
typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
WDFAPI
VOID
(*PFN_NETADAPTEROFFLOADSETCHECKSUMCAPABILITIES)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _In_
    NETADAPTER Adapter,
    _In_
    PNET_ADAPTER_OFFLOAD_CHECKSUM_CAPABILITIES HardwareCapabilities,
    _In_
    PFN_NET_ADAPTER_OFFLOAD_SET_CHECKSUM EvtAdapterOffloadSetChecksum
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
VOID
FORCEINLINE
NetAdapterOffloadSetChecksumCapabilities(
    _In_
    NETADAPTER Adapter,
    _In_
    PNET_ADAPTER_OFFLOAD_CHECKSUM_CAPABILITIES HardwareCapabilities,
    _In_
    PFN_NET_ADAPTER_OFFLOAD_SET_CHECKSUM EvtAdapterOffloadSetChecksum
    )
{
    ((PFN_NETADAPTEROFFLOADSETCHECKSUMCAPABILITIES) NetFunctions[NetAdapterOffloadSetChecksumCapabilitiesTableIndex])(NetDriverGlobals, Adapter, HardwareCapabilities, EvtAdapterOffloadSetChecksum);
}

//
// NET Function: NetAdapterOffloadSetLsoCapabilities
//
typedef
_IRQL_requires_max_(PASSIVE_LEVEL)
WDFAPI
VOID
(*PFN_NETADAPTEROFFLOADSETLSOCAPABILITIES)(
    _In_
    PNET_DRIVER_GLOBALS DriverGlobals,
    _In_
    NETADAPTER Adapter,
    _In_
    PNET_ADAPTER_OFFLOAD_LSO_CAPABILITIES HardwareCapabilities,
    _In_
    PFN_NET_ADAPTER_OFFLOAD_SET_LSO EvtAdapterOffloadSetLso
    );

_IRQL_requires_max_(PASSIVE_LEVEL)
VOID
FORCEINLINE
NetAdapterOffloadSetLsoCapabilities(
    _In_
    NETADAPTER Adapter,
    _In_
    PNET_ADAPTER_OFFLOAD_LSO_CAPABILITIES HardwareCapabilities,
    _In_
    PFN_NET_ADAPTER_OFFLOAD_SET_LSO EvtAdapterOffloadSetLso
    )
{
    ((PFN_NETADAPTEROFFLOADSETLSOCAPABILITIES) NetFunctions[NetAdapterOffloadSetLsoCapabilitiesTableIndex])(NetDriverGlobals, Adapter, HardwareCapabilities, EvtAdapterOffloadSetLso);
}



WDF_EXTERN_C_END

#endif // _NETADAPTER_H_

